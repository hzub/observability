<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <title>reveal.js</title>

    <link rel="stylesheet" href="dist/reset.css" />
    <link rel="stylesheet" href="dist/reveal.css" />
    <link rel="stylesheet" href="dist/theme/black.css" />

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/zenburn.css" />
    <link href="tailwind.css" rel="stylesheet" />
    <!-- <script src="plugin/highlight/highlight.js"></script> -->
  </head>
  <body>
    <div class="reveal">
      <!-- <div class="slides" data-load="slides_intro.html"></div> -->
      <!-- <div class="slides"></div> -->
      <div class="slides">
        <section>
          <strong class="text-orange-300">JS</strong> jak JavaScript,
          <strong class="text-blue-300">O</strong> jak Observability
          <p class="text-2xl">Hubert Zub, Future Conf 2023</p>
          <aside class="notes">
            <li>nazywam się Hubert</li>
            <li>dziękuję za zaproszenie Andrzejowi</li>
            <li>z Białegostoku</li>
            <li>Jutro o AI, dziś o JS</li>
            <li>no właśnie - AI przetwarza sporo danych...</li>
            <li>Bez tego żadna nowoczesna appka</li>
          </aside>
        </section>
        <section>
          <div>
            <p>Kto mówi?</p>
            <p class="fragment">Hubert</p>
            <ul class="fragment">
              <li>meet.js</li>
              <li><img width="40" height="40" src="logo.png" /> Databricks</li>
            </ul>
            <img src="download.jpeg" width="300" class="fragment" />
          </div>
          <aside class="notes">
            <li>data warehousy, lakes, przetwarzanie danych</li>
            <li>eksabajty danych</li>
            <li>
              databricks - możliwe że nie słyszeliście, ale jesteście klientem
              firmy która jest naszym klientem
            </li>
            <li>apple, adobe, cisco, hp, toyota, siemens</li>
          </aside>
        </section>
        <section>
          <section>
            <span style="opacity: 0.3"
              ><strong class="text-orange-300">JS</strong> jak JavaScript, </span
            ><strong class="text-blue-300">O</strong> jak Observability
            <aside class="notes">
              <li>teraz by wypadała definicja</li>
              <li>wszyscy lubią definiować</li>
              <li>i mogą się o to bić (testy e2e, framework vs biblioteka)</li>
              <li>zdefiniujmy sami</li>
            </aside>
          </section>
          <section>
            Co musimy wiedzieć o aplikacji na produkcji?
            <aside class="notes">
              <li>czy działa</li>
              <li>a co to znaczy</li>
              <li>że userzy mogą klikać w featury</li>
              <li>że te featury działają</li>
              <li>że te featury działają szybko</li>
              <li>że te featury są znajdowalne przez userów!</li>
            </aside>
          </section>
          <!-- <section>
            Czy to...
            <span class="r-stack">
              <span class="fragment fade-out" data-fragment-index="0"
                >zbieranie logów?</span
              >
              <span class="fragment current-visible" data-fragment-index="0"
                >statystyka błędów?</span
              >
              <span class="fragment">xxgz logów?</span>
            </span>
          </section> -->
          <section>
            A kto tego potrzebuje?
            <aside class="notes">
              <li>appka stoi, zrobiona, wypuszczona - kto potrzebuje</li>
              <li>
                czy my jako programiści potrzebujemy zbierania dużęj ilości
                logów userzy korzystają z apki
              </li>
              <li>
                my może nie, ale ci od produktu chcą wiedzieć czy mamy błędy w
                aplikacji
              </li>
              <li>albo czy aplikacja szybko działa</li>
              <li>albo czy featury które tworzymy w ogóle są wykorzystywane</li>
            </aside>
          </section>
          <section>
            <p>Czyli po pierwsze: <strong>błędy</strong></p>
            <aside class="notes">
              zrobiliście aplikację, wiecie że jest bez błędów bo przecież
              popisaliście testy, wysyłacie na produkcję. Checie słyszeć o
              błędach? No nie. Ale wasz account już tak, bo jak błędy będą
              krytyczne to on świeci oczami.
            </aside>
          </section>
          <section>
            <p>Po drugie: <strong>performance</strong></p>
            <aside class="notes">
              jak pisaliście apkę to przecież śmigała szybko. A nawet jak było
              coś wolno to zoptymalizowaliście. Przeskanowaliście web vitals,
              wszystko śmiga. To po co się tym przejmować jak jest szybko. Jak
              coś wolno to wiadomo że to wina tych na backendzie. No ale
              tworzyliście appkę na jakimś macbooku który ma 12 rdzeni i 32 gb
              ramu bo wam firma kupiła. A user może mieć biurowy komputer na
              przysłowiowy węgiel. I póki.
            </aside>
          </section>
          <section>
            <p>Po trzecie: <strong>analityka zdarzeń</strong></p>
            <aside class="notes">
              czy potrzebujecie tego? Przecież UX/UI zaprojektował, narysował,
              frontend jest postawiony wg designu. Potrzebujecie wiedzieć jak
              userzy klikają w które przyciski etc.? Może tak, może nie, ale
              dział produktowy potrzebuje wiedzieć czy zaprojektował interfejs
              który jest jasny. Mógł zrobić testy UXowe z userami, ale to małą
              skala. I kosztuje.
            </aside>
          </section>
          <section>
            <p>
              Czemu te rzeczy <em><strong>obserwujemy</strong></em
              >?
            </p>
            <aside class="notes">
              <li>Czemu nie sprawdzimy tego wcześniej</li>
              <li>tylko teraz?</li>
              <li>
                observability pozwala nam robić (jedyne legalne) testy na
                produkcji - z DUŻą ilością userów
              </li>
              <li>zweryfikować błędy</li>
            </aside>
          </section>
          <section>
            <p>Umówmy się 😉 że observability to:</p>
            <ul>
              <li>Raportowanie błędów</li>
              <li>Metryki wydajności</li>
              <li>Analityka zdarzeń</li>
            </ul>
            <p class="fragment">...obserwowane na produkcji</p>
            <aside class="notes">
              <li>
                to jest robocza definicja na potrzeby prezentacji, wierzę mocno
                że masa ludzi chciałaby to zdefiniować inaczej - bardzo chętnie
                się o to podyskutuje ale po prezce :)
              </li>
            </aside>
          </section>

          <section>
            <p>Inglisz 🇬🇧:</p>
            <ul>
              <li>error reporting</li>
              <li>performance metrics</li>
              <li>event analytics</li>
            </ul>
          </section>
          <section>
            O czym NIE jest ta prezentacja?
            <aside class="notes">
              <li>RAZ</li>
              <li>nie będziemy omawiać narzędzi - do tego są tutoriale</li>
              <li>lockrocket, datadog, sentry, grafana etc.</li>
              <li>
                może nawet na swoim backendzie macie customowe rozwiązanie etc.
              </li>
              <li>
                nie mówię jak zestawić - ale jak działać na frontendzie, by te
                observability miało sens
              </li>
              <li>DWA</li>
              <li>nie będę wam mówił ze warto</li>
              <li>bo to troche jak prezka o tym żę warto pisać testy</li>
            </aside>
          </section>
          <section>
            <p>O czym jest ta prezentacja?</p>

            <aside class="notes">
              <li>dotkniemy każdego tematu ze strony frontendu</li>
              <li>zwrócić uwagę na uniwersalne praktyki, pułapki etc</li>
              <li>pokazać ciekawostki</li>
              <li>JAK PISAĆ APKI KTÓRE DA SIĘ OBSERWOWAĆ</li>
              <li>
                problem: każdy z tych tematów to może być oddzielna prezka, no
                ale...
              </li>
            </aside>
          </section>

          <section>
            <ul>
              <li class="fragment">Raportowanie błędów</li>
              <li class="fragment">Metryki wydajności</li>
              <li class="fragment" style="opacity: 0.3">Analityka zdarzeń</li>
            </ul>
          </section>

          <!-- <section>
            <p>Wyobrażamy sobie że:</p>
            <ul>
              <li class="fragment">
                Posiadamy już zainstalowany i spięty system do metryk
              </li>
              <li class="fragment">Chcemy by spełniał swoją rolę</li>
            </ul>
          </section> -->
        </section>

        <section data-background="#d57b7b">
          <section>
            <p>Część I</p>
            <p><strong>Błędy</strong></p>
          </section>
          <section>
            <p>Potrzebujemy?</p>
            <aside class="notes">
              <li>
                Już rozmawialiśmy - wypuszczacie bezbłędne aplikacje? JAk nie to
              </li>
              <li>
                Zakładamy że mamy super CI więc żadne błędy czasu budowy:
                syntaxy etc. nie przejdą więc interesują nas tylko runtime’y
              </li>
            </aside>
          </section>
          <section>
            <p>To co robimy z tymi błędami 🤔</p>
            <ol>
              <li class="fragment">Nic</li>
              <li class="fragment">Ładny modal + wyślij proszę email</li>
              <li class="fragment">
                <strong>Ładny modal + automatyczne raportowanie</strong>
              </li>
            </ol>
            <aside class="notes">
              <li>BANAŁ</li>
              <li>1: nic nie robimy</li>
              <li>2: wyświetlamy ładny modal + email</li>
              <li>3: automatyzujemy</li>
            </aside>
          </section>

          <section>
            <p>Przypominajka/wyjaśnienie</p>
            <img src="img/sch/error.png" />
          </section>
          <section>Efekt skali</section>
          <section>
            <p>Jak?</p>
            <ul>
              <li class="fragment">
                Z pomocą narzędzi: Sentry, LogRocket etc.
              </li>
              <li class="fragment">
                Po swojemu: własny system do raportowania
              </li>
            </ul>
            <p class="fragment">
              Cel: statystyka, reprodukcja, zaraportowanie, naprawa
            </p>
            <aside class="notes">
              <li>BANAŁ</li>
              <li>może tak</li>
              <li>a moze tak</li>
            </aside>
          </section>
          <section>
            <img src="img/tools/sentry.jpg" />
          </section>
        </section>

        <section data-background="#d57b7b">
          <section data-background="#d57b7b">
            <p>Pułapki i praktyki</p>
          </section>
          <section>
            <p>Pułapka #1</p>
            <p><strong>Logujemy za mało</strong></p>
            <aside class="notes">
              <li>BANAŁ</li>
              <li>klasyk</li>
            </aside>
          </section>
          <section>
            <pre><code data-line-numbers="4-8|13-21|23-27|5-7|18-20" data-trim>class ApiService {
	async call() {
		const response = await fetch("...");
		if (!response.ok) {
			return Promise.reject(new Error(
        "Failed to fetch [URL]"
      ));
		}
		return response.json();
	}
}

function process() {
	new ApiService().call()
	  .then((data) => {
		  // ...
	  })
	  .catch((error) => {
		  // ?
	  });
}

document
	.querySelector("button")
	.addEventListener("click", () => {
		process();
	});
  </code></pre>
          </section>
          <section>
            <pre><code data-trim>
              .catch((error) => {
                console.log(error);
              });
			  </code></pre>
          </section>
          <section>
            <img src="img/bledy/1.png" width="100%"" />
            <p class="fragment">Z grubsza wszystko co wiemy ☝️</p>
            <p class="fragment">Jaki ticket z tego wyjdzie?</p>
          </section>
          <section>
            <p>Co pomoże (łatwe)?</p>
            <ul>
              <li class="fragment">Pełny stack trace</li>

              <li class="fragment">URL / historia URLi (route-ów)</li>

              <li class="fragment"><code>navigator.*</code></li>
            </ul>
          </section>
          <section>
            <p>Co jeszcze pomoże?</p>
            <ul>
              <li class="fragment">odbitka feature flag</li>
              <li class="fragment">ewaluacja A/B</li>
            </ul>
          </section>
        </section>
        <section data-background="#d57b7b">
          <section>
            <p>Stack trace</p>
          </section>
          <section>
            <pre><code data-line-numbers="1-11|13-21|23-27|5-7|18-20" data-trim>class ApiService {
  async call() {
    const response = await fetch("...");
    if (!response.ok) {
      return Promise.reject(new Error(
        "Failed to fetch [URL]"
      ));
    }
    return response.json();
  }
}

function process() {
  new ApiService().call()
    .then((data) => {
      // ...
    })
    .catch((error) => {
      console.log(error.stack)
    });
}</code></pre>
          </section>
          <section><img src="img/bledy/1.png" width="100%" /></section>
          <section>
            <pre><code data-line-numbers="2|3-6" data-trim>function process() {
  const initiatorStack = new Error().stack;
  new ApiService().call().catch((error) => {
    console.log(error.stack);
    console.log(initiatorStack);
  });
}

document.querySelector("button").addEventListener("click", () => {
  process();
});
</code></pre>
          </section>
          <section><img src="img/bledy/3.png" /></section>
          <section>
            <pre><code data-line-numbers="4-8" data-trim>function process() {
  const initiatorStack = new Error().stack;
  new ApiService().call().catch((error) => {
    const completeStack = [
      error.stack,
      ...initiatorStack.split("\n").slice(1),
    ].join("\n");
    console.log(completeStack);
  });
}</code></pre>
          </section>
          <section><img src="img/bledy/4.png" /></section>
          <section>
            Nie logujmy za mało...
            <aside class="notes"></aside>
          </section>
        </section>
        <section data-background="#d57b7b">
          <section>
            <p>Pułapka #2</p>
            <p><strong>Logujemy za dużo</strong></p>
            <aside class="notes">
              <li>można?</li>
            </aside>
          </section>
          <section>
            <img src="img/bledy/2.png" />
            <p class="fragment">Co tu jest nie tak?</p>
          </section>
          <section>
            <pre><code data-trim>{
  "exception": {
    "code": "403",
    "error": "Unauthorized"
  },
  "request": {
    "method": "POST",
    "resource": "/api/tables/1341",
    "body": {
      "operation": "register",
      "withToken": "NjEzMjMxNTg2MDM4NTAxMTY1MzA3MzM3MDYwNDQ3NzU1ODM2OTc5NDE0MjgxODM1"
    }
  }
}</code></pre>
          </section>
          <section>
            <p>Konstruując błędy, raporty, logi:</p>
            <p class="fragment">✂️</p>
            <aside class="notes">
              <li>Zwyczajowo wycinamy dane użytkownika</li>
              <li>Wystarczą: identyfikatory, URLe, klucze</li>
              <li>Jak nie, to przemyślmy architekturę</li>
              <li>Z wyjątków: wycinajmy tokeny, klucze, hasła etc.</li>
              <li>Im mniej danych użytkownika tym lepiej</li>
              <li>A skoro o userze mowa</li>
            </aside>
          </section>
        </section>
        <section data-background="#d57b7b">
          <section>
            <p>Pułapka #3</p>
            <p><strong>Brak informacji od użytkownika</strong></p>
            <aside class="notes">
              <li>Pod spodem ładnie wysyła się błąd</li>
              <li>A na wierzchu?</li>
            </aside>
          </section>
          <section><img src="img/bledy/5.png" width="100%" /></section>
          <section>
            <p>Cel?</p>
            <p class="fragment">Maksymalizacja reprodukowalności</p>
          </section>
          <section><img src="img/bledy/6.png" width="100%" /></section>
          <section>
            <h2>Obserwacja:</h2>
            <p>
              Użytkownicy częściej niż nam się wydaje podają dodatkowe dane.
            </p>
            <p>
              <strong>Użytkownicy płacący jeszcze częściej.</strong>
            </p>
          </section>
          <section>
            <p>Czy można lepiej?</p>
            <p class="fragment">A zrzut ekranu? 🤔</p>
          </section>
          <section>
            <pre><code data-trim data-line-numbers="|2-6|8-12|14-21">async function snapshot() {
  const stream = await navigator.mediaDevices
    .getDisplayMedia({
      preferCurrentTab: true,
    });
  const [track] = stream.getVideoTracks();

  const canvas = document.createElement("canvas");
  const video = document.createElement("video");
  video.srcObject = stream;

  await video.play();

  canvas.width = video.videoWidth;
  canvas.height = video.videoHeight;
  canvas.getContext("2d").drawImage(video, 0, 0);

  canvas.toBlob((blob) => {
    track.stop();
    // Przetworzenie + wysłanie bloba
  });
}
</code></pre>
          </section>
          <section><img src="img/bledy/7.png" width="100%" /></section>
          <section>Z autopsji: ☝️ mocno pomogło lokalizować błędy</section>
        </section>
        <section data-background="#d57b7b">
          <section>
            <p>Pułapka #4</p>
            <p><strong>Niespójny system logowania</strong></p>
            <aside class="notes"></aside>
          </section>
          <section>
            <pre><code data-trim data-line-numbers="1-13|15-18|20-23|25-30">
class ErrorWrapper extends Error {
  constructor(
    private error: string,
    private errorCode: number,
    private stackTrace = new Error().stack
  ) {
    super(error);
  }
  serialize() {
    const { error, stackTrace, errorCode } = this;
    return { error, stackTrace, errorCode };
  }
}

function doSomething1() {
  // ...
  throw new ErrorWrapper("Unauthorized", 401);
}

function doSomething2() {
  // ...
  throw { code: 401, message: "Unauthorized" };
}

function doSomething3() {
  // ...
  throw new Error(JSON.stringify(
    { code: 401, message: "Unauthorized" }
  ));
}

            </code></pre>
          </section>
        </section>
        <section data-background="#d57b7b">
          <section>
            <p>Pułapka #5</p>
            <p><strong>Testowanie raportowania</strong></p>
          </section>
          <section>
            <center>
              <img src="img/tools/mem.jpg" />
            </center>
            <aside class="notes">
              <li>odpalacie system, stawiacie sentry czy coś tam</li>
              <li>i nie ma błędów</li>
              <li>...i nie ma błędów</li>
              <li>to dobrze, prawda?</li>
              <li>warto napisać test który zmockowane</li>
            </aside>
          </section>
          <section>
            <h1>🥸</h1>
            <aside class="notes">
              <li>
                a bardziej warto napisać e2e który będzie siedział w waszym CI i
                raz na miesiąc faktycznie wysypie stronę i zgłosi faktyczny
                raport
              </li>
            </aside>
          </section>
        </section>

        <section data-background="#d57b7b">
          <p>Podsumowanie części o błędach</p>
          <ul>
            <li class="fragment">Minimum do reprodukcji</li>
            <li class="fragment">Uważajmy co raportujemy</li>
            <li class="fragment">Pełne zrzuty stosów</li>
            <li class="fragment">Spójna forma</li>
            <li class="fragment">Testujmy!</li>
          </ul>
        </section>
        <section data-background="#3c3355">
          <section>
            <p>Część II</p>
            <p><strong>Wydajność</strong></p>
          </section>
          <section>
            <p>Dlaczego?</p>
            <aside class="notes">
              <li>Znowu - problem macbooka programisty</li>
              <li>
                Celem jest by appka była szybka/używalna przez wszystkich na
                większości maszyn
              </li>
              <li>(chyba że nie, ale to dziwny model biznesowy)</li>
            </aside>
          </section>
          <section>
            <p><em>"Czy aplikacja jest wystarczająco szybka"</em></p>
            <p class="fragment">Jak na to odpowiedzieć?</p>
          </section>
          <section>
            <p>Możemy zmierzyć:</p>
            <ul>
              <li class="fragment">
                Czas renderu ekranów (poszczególnych części)
              </li>
              <li class="fragment">Wąskie gardła, blokujące taski</li>
              <li class="fragment">Wielkość pobieranych danych</li>
              <li class="fragment">Chrome Lighthouse</li>
              <li class="fragment">...</li>
            </ul>
          </section>
          <section>
            Czy to odpowiada na pytanie?
            <aside class="notes">
              <li>Może odpowiada, ale nie używamy wtedy wcale observability</li>
            </aside>
          </section>
        </section>
        <section data-background="#3c3355">
          <section>
            <p>Pułapka #1</p>
            <p>
              <strong>Mierzymy tylko szczegóły</strong>
            </p>
          </section>

          <section>
            <p>Co tak naprawdę nas interesuje?</p>
            <p class="fragment">A gdyby tak E2E?</p>
            <aside class="notes">
              <li>Co tak naprawdę nas interesuje?</li>
              <li>
                MOŻEMY Czas responsów z API. Wiecie, jak za długie to problem bo
                też apka wolno działa. Ale to problem backendu, infry od
                networku, chmurowców - każdy zmierzy po swojemu.
              </li>
              <li>MOŻEMY czas ekranów</li>
              <li>MOŻEMY zasoby</li>
              <li>
                Ale my na frontendzie mamy wyjątkową, w zasadzie najlepszą
                pozycję do mierzenia
              </li>
              <li>JAKI INNY AKTOR potrafi zebrtać tak dane</li>
            </aside>
          </section>
          <section>
            <center><img src="img/sch/perf.png" /></center>
            <aside class="notes">
              <li>Start jakiejś akcji (INTERAKCJI) - nawigacja, klik etc</li>
              <li>Coś się dzieje.</li>
              <li>Może to być ładowanie strony</li>
              <li>Może to być ładowanie kolejnej strony czyli nawigacja</li>
              <li>
                Może to być akcja która odzywa się do API i coś przetwarza
              </li>
              <li>Co interesuje userów? Kiedy mogą robić dalej</li>
            </aside>
          </section>
          <section>
            <ul>
              <li>
                Start:<br />
                <strong
                  >otwarcie aplikacji, nawigacja, akcja użytkownika</strong
                >
              </li>
              <br />
              <li>Koniec:<br /><strong>interaktywność?</strong></li>
            </ul>
          </section>
          <section>I to można mierzyć</section>
          <section>
            <p>Jak można działać:</p>
            <ul>
              <li class="fragment">
                Zdefiniowanie/nazwanie każdej interakcji (scenariusza, UJ, ...)
              </li>
              <li class="fragment">Raportowanie pełnego czasu interakcji</li>
              <li class="fragment">Od interaktywności do interaktywności</li>
              <li class="fragment">+ dopełnienie suchymi danymi</li>
            </ul>
          </section>
          <section>
            <p>Pomysły na implementację?</p>
            <ul>
              <li class="fragment">
                Rozpoczynanie interakcji przy nawigacji (nasłuch na routerze)
              </li>
              <li class="fragment">
                Rozpoczynanie interakcji na żądanie (zdarzenie na elemencie)
              </li>
              <li class="fragment">Zależnie od frameworka</li>
            </ul>
          </section>

          <section>
            <pre><code data-line-numbers="|2-5"><script type="text/template">const Routes = () => {
  useEffect(() => {
    const interaction = getInteraction(location.path);
    startInteraction(location.path);
  }, [location])
  
  return (
    <Switch>
      <Route path="/tables" element={...} />
      <Route path="/users" element={...} />
    </Switch>
  );
}

</script></code></pre>
          </section>
          <section>
            <pre><code data-line-numbers="|2-5,10"><script type="text/template">const View = () => {
  const loadUsers = useCallback(() => {
    startInteraction('LOADING_USERS');
    fetchUsersFromApi(...);
  }, [])
  
  return (
    <div>
      {/* ... */}
      <button onClick={loadUsers}>Load</button>
    </div>
  );
}

</script></code></pre>
          </section>

          <section>
            <pre><code data-line-numbers="|9-14"><script type="text/template">const View = () => {
  const [loading, setLoading] = useState(true);
  const [data, setData] = useState(null);
  
  useEffect(... => ...)
  
  return (
    <div>
      <InteractionBlock
        name="PAGE_CLIENTS_TABLE_VIEW" 
        isBlocked={loading}
      >
        {loading ? <Spinner /> : data.map(... => ...)}
      </Interation>
    </div>
  );
}

</script></code></pre>
          </section>

          <section>
            <pre><code data-line-numbers="10-14"><script type="text/template"><div class="feed-toggle">
  <ul class="nav nav-pills outline-active">
    
    <li [hidden]="!listConfig.filters.tag">
      <a class="nav-link active">
        {{ listConfig.filters.tag }}
      </a>
    </li>
  </ul>
  <interaction-pending
    name="CLIENT_TABLE_LOADING"
    [loading]="loading"
  >
  </interaction-pending>
</div></script></code></pre>
          </section>

          <section>
            <p>A kiedy skończyć i zaraportować?</p>
            <p class="fragment">Podpowiedź: interaktywność</p>
          </section>
          <section>
            <h1>🤔</h1>
          </section>
          <section>
            <pre><code><script type="text/template">requestAnimationFrame(() => {
  // Odblokowanie
});</script></code></pre>
          </section>
          <section>
            <pre><code><script type="text/template">requestAnimationFrame(() => {
  requestAnimationFrame(() => {
    // Odblokowanie
  });
});</script></code></pre>
            <aside class="notes">
              <li>
                pierwszy rAF moze jeszcze wykonac się w tej samej ramce
                wykonania
              </li>
              <li>zagnieżdżony będzie na bank w kolejnej</li>
            </aside>
          </section>
          <section>
            <center><img src="img/sch/perf.png" /></center>
            <aside class="notes">
              <li>Z autopsji: ☝️ działa całkiem nieźle</li>
            </aside>
          </section>
        </section>
        <section data-background="#3c3355">
          <section>
            <p>A co ze szczegółami?</p>
            <ul>
              <li class="fragment">Wąskie gardła</li>
              <li class="fragment">Ilość zasobów</li>
            </ul>
          </section>
          <section>
            <p>Wąskie gardła</p>
            <ul>
              <li class="fragment">Możemy dłubać ręcznie</li>
              <li class="fragment">...PerformanceObserver API</li>
            </ul>
          </section>
          <section>
            <pre><code data-line-numbers>const observer = new PerformanceObserver((list) => {
  console.log(list.getEntries()[0]);
});

observer.observe({
  type: "longtask",
});
            </code></pre>
          </section>
          <section>
            <pre><code data-trim data-line-numbers="|1-3|5-11|13-19"><script type="text/template">
<body>
  <div>test</div>
</body>

const observer = new PerformanceObserver((list) => {
  console.log(list.getEntries()[0]);
});

observer.observe({
  type: "longtask",
});

setTimeout(() => {
  for (let i = 0; i < 500; i++) {
    for (let j = 0; j < 500; j++) {
      document.querySelector("div").innerHTML = "x";
    }
  }
}, 1000);
            </script></code></pre>
          </section>
          <section>
            <img src="img/perf/1.png" width="100%" />
          </section>
          <section>
            <pre><code data-trim data-line-numbers="7-16|14"><script type="text/template">
const observer = new PerformanceObserver((list) => {
  for (const item of list.getEntries()) {
    console.log(item);
  }
});

observer.observe({
  entryTypes: [
    "mark",
    "measure",
    "longtask",
    "paint",
    "navigation",
    "resource",
  ],
});
            </script></code></pre>
          </section>
          <section>
            <img src="img/perf/2.png" width="100%" />
          </section>
          <section>
            <img src="img/perf/3.png" width="100%" />
          </section>
        </section>
        <section data-background="#3c3355">
          <section>
            <p>Pułapka #2</p>
            <p><strong>Pomiar wpływa na pomiar</strong></p>
          </section>
          <section>
            <p>TODO: Przykład</p>
          </section>
          <section>
            <div>Rozwiązanie</div>
            <ul>
              <li>Kolejkowanie</li>
              <li>Sampling</li>
            </ul>
          </section>
        </section>
        <!-- <section data-background="#3c3355">
          <section>
            <p>Pułapka #3</p>
            <p><strong>Kiepsko nazwane interakcje/scenariusze</strong></p>
          </section>
          <section>[SCREEN - "page load time"]</section>
        </section> -->

        <section data-background="#3c3355">
          <p>Podsumowanie części wydajności</p>
          <ul>
            <li class="fragment">Pomiary E2E</li>
            <li class="fragment">Organizacja interakcji</li>
            <li class="fragment">PerformanceObserver</li>
          </ul>
        </section>
        <section data-background="#185642">
          <p>Część #3: Analityka</p>
        </section>
      </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script>
      // More info about initialization & config:
      // - https://revealjs.com/initialization/
      // - https://revealjs.com/config/
      Reveal.initialize({
        hash: true,

        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes],
      });
    </script>
  </body>
</html>
